/*
     ZZZZZZZZZZZZZZZZZZZZ    8888888888888       00000000000
   ZZZZZZZZZZZZZZZZZZZZ    88888888888888888    0000000000000
                ZZZZZ      888           888  0000         0000
              ZZZZZ        88888888888888888  0000         0000
            ZZZZZ            8888888888888    0000         0000       AAAAAA         SSSSSSSSSSS   MMMM       MMMM
          ZZZZZ            88888888888888888  0000         0000      AAAAAAAA      SSSS            MMMMMM   MMMMMM
        ZZZZZ              8888         8888  0000         0000     AAAA  AAAA     SSSSSSSSSSS     MMMMMMMMMMMMMMM
      ZZZZZ                8888         8888  0000         0000    AAAAAAAAAAAA      SSSSSSSSSSS   MMMM MMMMM MMMM
    ZZZZZZZZZZZZZZZZZZZZZ  88888888888888888    0000000000000     AAAA      AAAA           SSSSS   MMMM       MMMM
  ZZZZZZZZZZZZZZZZZZZZZ      8888888888888       00000000000     AAAA        AAAA  SSSSSSSSSSS     MMMM       MMMM

Copyright (C) Gunther Strube, InterLogic 1993-99
*/

/* $Header: /home/dom/z88dk-git/cvs/z88dk/src/z80asm/modlink.c,v 1.26 2011-08-19 10:20:32 pauloscustodio Exp $ */
/* $Log: modlink.c,v $
/* Revision 1.26  2011-08-19 10:20:32  pauloscustodio
/* - Factored code to read/write word from file into xfget_word/xfput_word.
/* - Renamed ReadLong/WriteLong to xfget_long/xfput_long for symetry.
/*
/* Revision 1.25  2011/08/18 23:27:54  pauloscustodio
/* BUG_0009 : file read/write not tested for errors
/* - In case of disk full file write fails, but assembler does not detect the error
/*   and leaves back corruped object/binary files
/* - Created new exception FileIOException and ERR_FILE_IO error.
/* - Created new functions xfputc, xfgetc, ... to raise the exception on error.
/*
/* Revision 1.24  2011/08/18 21:46:54  pauloscustodio
/* BUG_0008 : code block of 64K is read as zero
/*
/* Revision 1.23  2011/08/15 17:12:31  pauloscustodio
/* Upgrade to Exceptions4c 2.8.9 to solve memory leak.
/*
/* Revision 1.22  2011/08/14 19:42:07  pauloscustodio
/* - LinkModules(), ModuleExpr(), CreateBinFile(), CreateLib(): throw the new exception FatalErrorException for fatal error ERR_FILE_OPEN
/*
/* Revision 1.21  2011/08/05 19:56:37  pauloscustodio
/* CH_0004 : Exception mechanism to handle fatal errors
/* Replaced all ERR_NO_MEMORY/return sequences by an exception, captured at main().
/* Replaced all the memory allocation functions malloc, calloc, ... by corresponding
/* macros xmalloc, xcalloc, ... that raise an exception if the memory cannot be allocated,
/* removing all the test code after each memory allocation.
/* Replaced all functions that allocated memory structures by the new xcalloc_struct().
/* Replaced all free() by xfree0() macro which only frees if the pointer in non-null, and
/* sets the poiter to NULL afterwards, to avoid any used of the freed memory.
/* Created try/catch sequences to clean-up partially created memory structures and rethrow the
/* exception, to cleanup memory leaks.
/* Replaced 'l' (lower case letter L) by 'len' - too easy to confuse with numeral '1'.
/*
/* Revision 1.20  2011/07/18 00:48:25  pauloscustodio
/* Initialize MS Visual Studio DEBUG build to show memory leaks on exit
/*
/* Revision 1.19  2011/07/14 01:32:08  pauloscustodio
/*     - Unified "Integer out of range" and "Out of range" errors; they are the same error.
/*     - Unified ReportIOError as ReportError(ERR_FILE_OPEN)
/*     CH_0003 : Error messages should be more informative
/*         - Added printf-args to error messages, added "Error:" prefix.
/*     BUG_0006 : sub-expressions with unbalanced parentheses type accepted, e.g. (2+3] or [2+3)
/*         - Raise ERR_UNBALANCED_PAREN instead
/*
/* Revision 1.18  2011/07/12 22:47:59  pauloscustodio
/* - Moved all error variables and error reporting code to a separate module errors.c,
/*   replaced all extern declarations of these variables by include errors.h,
/*   created symbolic constants for error codes.
/* - Added test scripts for error messages.
/*
/* Revision 1.17  2011/07/11 16:00:34  pauloscustodio
/* Moved all option variables and option handling code to a separate module options.c,
/* replaced all extern declarations of these variables by include options.h.
/* Created declarations in z80asm.h of objects defined in z80asm.c.
/*
/* Revision 1.16  2011/07/09 18:25:35  pauloscustodio
/* Log keyword in checkin comment was expanded inside Log expansion... recursive
/* Added Z80asm banner to all source files
/*
/* Revision 1.15  2011/07/09 17:36:09  pauloscustodio
/* Copied cvs log into Log history
/*
/* Revision 1.14  2011/07/09 01:46:00  pauloscustodio
/* Added Log keyword
/* 
/* Revision 1.13  2011/07/09 01:20:55  pauloscustodio
/* added casts to clean up warnings
/* 
/* Revision 1.12  2010/09/19 02:37:57  dom
/* 64bit issue
/* 
/* Revision 1.11  2010/09/19 00:06:20  dom
/* Tweaks for compiling code generated by sdcc - it generates XREF rather than
/* LIB so treat XREF as a LIB (this possibly should be the default)
/* 
/* Do some _ mapping magic when in sdcc so standard z88dk libs can be used
/* (wrong _ convention chosen a long time ago...)
/* 
/* Have -forcexlib flag which treats MODULE as XLIB.
/* 
/* Revision 1.10  2010/04/16 17:34:37  dom
/* Make line number an int - 32768 lines isn't big enough...
/* 
/* Revision 1.9  2009/09/28 23:14:13  dom
/* Get the length of the right name.
/* 
/* Revision 1.8  2009/09/03 17:42:12  dom
/* Remove endian reading kludge and make work on 64 bit
/* 
/* Revision 1.7  2009/08/14 22:23:12  dom
/* clean up some compiler warnings
/* 
/* Revision 1.6  2009/07/23 20:35:14  dom
/* Get the end position right here as well
/* 
/* Revision 1.5  2009/07/17 22:06:48  dom
/* Experimental code to allow a LIB directive to refer to a globally exported
/* symbol from a module.
/* 
/* Should provide a better way of doing the ASMDISP stuff.
/* 
/* Revision 1.4  2002/11/05 11:45:56  dom
/* powerpc endian detection
/* 
/* fix for 64 bit machines, sizeof(long) != 4
/* 
/* Revision 1.3  2002/10/22 19:21:10  dom
/* that shouldn't have been committed (oops)
/* 
/* Revision 1.2  2002/10/22 19:15:28  dom
/* Makefile changes to use $(RM) instead of rm
/* 
/* Revision 1.1  2000/07/04 15:33:30  dom
/* branches:  1.1.1;
/* Initial revision
/* 
/* Revision 1.1.1.1  2000/07/04 15:33:30  dom
/* First import of z88dk into the sourceforge system <gulp>
/* 
/* */

/* $History: MODLINK.C $ */
/*  */
/* *****************  Version 16  ***************** */
/* User: Gbs          Date: 26-01-00   Time: 22:10 */
/* Updated in $/Z80asm */
/* Expression range validation removed from 8bit unsigned (redundant). */
/*  */
/* *****************  Version 14  ***************** */
/* User: Gbs          Date: 6-06-99    Time: 20:06 */
/* Updated in $/Z80asm */
/* "PC" program counter changed to long (from unsigned short). */
/*  */
/* *****************  Version 12  ***************** */
/* User: Gbs          Date: 6-06-99    Time: 12:12 */
/* Updated in $/Z80asm */
/* Added Ascii Art "Z80asm" at top of source file. */
/*  */
/* *****************  Version 10  ***************** */
/* User: Gbs          Date: 6-06-99    Time: 11:30 */
/* Updated in $/Z80asm */
/* "config.h" included before "symbol.h" */
/*  */
/* *****************  Version 9  ***************** */
/* User: Gbs          Date: 30-05-99   Time: 1:00 */
/* Updated in $/Z80asm */
/* Redundant system include files removed. */
/* Createlib() rewritten to replace low I/O open() with fopen() and */
/* fread(). */
/*  */
/* *****************  Version 8  ***************** */
/* User: Gbs          Date: 2-05-99    Time: 18:06 */
/* Updated in $/Z80asm */
/* File IO errors now handled through new ReportIOError() function. */
/*  */
/* *****************  Version 6  ***************** */
/* User: Gbs          Date: 17-04-99   Time: 0:30 */
/* Updated in $/Z80asm */
/* New GNU programming style C format. Improved ANSI C coding style */
/* eliminating previous compiler warnings. New -o option. Asm sources file */
/* now parsed even though any line feed standards (CR,LF or CRLF) are */
/* used. */
/*  */
/* *****************  Version 5  ***************** */
/* User: Gbs          Date: 7-03-99    Time: 13:13 */
/* Updated in $/Z80asm */
/* Minor changes to keep C compiler happy. */
/*  */
/* *****************  Version 3  ***************** */
/* User: Gbs          Date: 4-09-98    Time: 0:10 */
/* Updated in $/Z80asm */
/* Various changes by Dominic Morris (ENDIAN #if). */
/*  */
/* *****************  Version 2  ***************** */
/* User: Gbs          Date: 20-06-98   Time: 15:10 */
/* Updated in $/Z80asm */
/* SourceSafe Version History Comment Block added. */

/* ifdef QDOS changed to ifdef ENDIAN to sort ENDIAN djm 26/6/98 */

#include "memalloc.h"	/* before any other include to enable memory leak detection */

#include <stdio.h>
#include <limits.h>
#include <stdlib.h>
#include <string.h>
#include "config.h"
#include "options.h"
#include "symbol.h"
#include "z80asm.h"
#include "errors.h"
#include "file.h"

/* external functions */
void FreeSym (symbol * node);
void RemovePfixlist (struct expr *pfixexpr);
struct module *NewModule (void);
struct libfile *NewLibrary (void);
struct sourcefile *Newfile (struct sourcefile *curfile, char *fname);
long EvalPfixExpr (struct expr *pass2expr);
int DefineDefSym (char *identifier, long value, unsigned char symtype, avltree ** root);
int cmpidstr (symbol * kptr, symbol * p);
int cmpidval (symbol * kptr, symbol * p);
int GetChar (FILE *fptr);
struct expr *ParseNumExpr (void);
symbol *FindSymbol (char *identifier, avltree * symbolptr);
symbol *CreateSymbol (char *identifier, long value, unsigned char symboltype, struct module *symowner);

/* local functions */
int LinkModule (char *filename, long fptr_base);
int LinkTracedModule (char *filename, long baseptr);
int LinkLibModules (char *objfilename, long fptr_base, long startnames, long endnames);
int LinkLibModule (struct libfile *library, long curmodule, char *modname);
int SearchLibfile (struct libfile *curlib, char *modname);
char *ReadName (void);
void redefinedmsg (void);
void CreateLib (void);
void SearchLibraries (char *modname);
void LinkModules (void);
void ModuleExpr (void);
void CreateBinFile (void);
void WriteExprMsg (void);
void DefineOrigin (void);
void WriteMapFile (void);
void ReadNames (long nextname, long endnames);
void ReadExpr (long nextexpr, long endexpr);
void ReOrderSymbol (avltree * node, avltree ** maproot, int (*symcmp) (void *, void *));
void WriteMapSymbol (symbol * mapnode);
void WriteGlobal (symbol * node);
void CreateDeffile (void);
void ReleaseLinkInfo (void);
static char *         CheckIfModuleWanted(FILE *z80asmfile, long currentlibmodule, char *modname);

/* global variables */
extern FILE *listfile, *mapfile, *z80asmfile, *errfile, *deffile, *libfile;
extern char line[], ident[];
extern char *lstfilename, *objfilename, *errfilename, *libfilename;
extern char objext[], segmbinext[], binext[], mapext[], errext[], defext[];
extern char Z80objhdr[];
extern enum symbols sym, GetSym (void);
extern enum flag writeline;
extern enum flag EOL, library;
extern long PC;
extern size_t CODESIZE;
extern unsigned char *codearea, PAGELEN;
extern unsigned char reloc_routine[];
extern int listfileptr;
extern struct modules *modulehdr;
extern struct liblist *libraryhdr;
extern struct module *CURRENTMODULE;
extern int PAGENR;
extern avltree *globalroot;
extern char *reloctable, *relocptr;
extern size_t sizeof_relocroutine;

struct linklist *linkhdr;
struct libfile *CURRENTLIB;
unsigned short totaladdr, curroffset, sizeof_reloctable;


void 
ReadNames (long nextname, long endnames)
{
  char scope, symtype;
  long value;
  symbol *foundsymbol;

  do
    {
      scope = xfgetc(z80asmfile);
      symtype = xfgetc(z80asmfile);	/* type of name   */
      value = xfget_long(z80asmfile);	/* read symbol (long) integer */
      ReadName ();			/* read symbol name */

      nextname += 1 + 1 + 4 + 1 + strlen (line);

      switch (symtype)
        {
        case 'A':
          symtype = SYMADDR | SYMDEFINED;
          value += modulehdr->first->origin + CURRENTMODULE->startoffset;	/* Absolute address */
          break;

        case 'C':
          symtype = SYMDEFINED;
          break;
        }

      switch (scope)
        {
        case 'L':
          if ((foundsymbol = FindSymbol (line, CURRENTMODULE->localroot)) == NULL)
            {
              foundsymbol = CreateSymbol (line, value, symtype | SYMLOCAL, CURRENTMODULE);
              E4C_ASSERT(foundsymbol != NULL);
              insert (&CURRENTMODULE->localroot, foundsymbol, (int (*)(void*,void*)) cmpidstr);
            }
          else
            {
              foundsymbol->symvalue = value;
              foundsymbol->type |= symtype | SYMLOCAL;
              foundsymbol->owner = CURRENTMODULE;
              redefinedmsg ();
            }
          break;

        case 'G':
          if ((foundsymbol = FindSymbol (line, globalroot)) == NULL)
            {
              foundsymbol = CreateSymbol (line, value, symtype | SYMXDEF, CURRENTMODULE);
              E4C_ASSERT(foundsymbol != NULL);
              insert (&globalroot, foundsymbol, (int (*)(void*,void*)) cmpidstr);
            }
          else
            {
              foundsymbol->symvalue = value;
              foundsymbol->type |= symtype | SYMXDEF;
              foundsymbol->owner = CURRENTMODULE;
              redefinedmsg ();
            }
          break;

        case 'X':
          if ((foundsymbol = FindSymbol (line, globalroot)) == NULL)
            {
              foundsymbol = CreateSymbol (line, value, symtype | SYMXDEF | SYMDEF, CURRENTMODULE);
              E4C_ASSERT(foundsymbol != NULL);
              insert (&globalroot, foundsymbol, (int (*)(void*,void*)) cmpidstr);
            }
          else
            {
              foundsymbol->symvalue = value;
              foundsymbol->type |= symtype | SYMXDEF | SYMDEF;
              foundsymbol->owner = CURRENTMODULE;
              redefinedmsg ();
            }

          break;
        }
    }
  while (nextname < endnames);
}



void 
redefinedmsg (void)
{
  printf ("Symbol <%s> redefined in module '%s'\n", line, CURRENTMODULE->mname);
}



void 
ReadExpr (long nextexpr, long endexpr)
{
  char type;
  long offsetptr;
  long constant, i, fptr;
  struct expr *postfixexpr;
  unsigned char *patchptr;

  do
    {
      type = xfgetc(z80asmfile);
      offsetptr = xfget_word(z80asmfile);

      /* assembler PC     as absolute address */
      PC = modulehdr->first->origin + CURRENTMODULE->startoffset + offsetptr;

      FindSymbol (ASSEMBLERPC, globalroot)->symvalue = PC;

      i = xfgetc(z80asmfile);	/* get length of infix expression */
      fptr = ftell (z80asmfile);	/* file pointer is at start of expression */
      fgets (line, i + 1, z80asmfile);	/* read string for error reference */
      fseek (z80asmfile, fptr, SEEK_SET);	/* reset file pointer to start of expression */
      nextexpr += 1 + 1 + 1 + 1 + i + 1;


      EOL = OFF;		/* reset end of line parsing flag - a line is to be parsed... */

      GetSym ();
      if ((postfixexpr = ParseNumExpr ()) != NULL)
        {			/* parse numerical expression */
          if (postfixexpr->rangetype & NOTEVALUABLE)
            {
              ReportError (CURRENTFILE->fname, 0, ERR_NOT_DEFINED);
              WriteExprMsg ();
            }
          else
            {
              constant = EvalPfixExpr (postfixexpr);
              patchptr = codearea + CURRENTMODULE->startoffset + offsetptr;	/* absolute patch pos.
                                                                             * in memory buffer */
              switch (type)
                {
                case 'U':
                  *patchptr = (unsigned char) constant;
                  break;

                case 'S':
                  if ((constant >= -128) && (constant <= 255))
                    *patchptr = (char) constant;	/* opcode is stored, now store signed 8bit value */
                  else
                    {
                      ReportError (CURRENTFILE->fname, 0, ERR_INT_RANGE, constant);
                      WriteExprMsg ();
                    }
                  break;

                case 'C':
                  if ((constant >= -32768) && (constant <= 65535))
                    {
                      *patchptr++ = (unsigned short) constant % 256U;
                      *patchptr = (unsigned short) constant / 256U;
                    }
                  else
                    {
                      ReportError (CURRENTFILE->fname, 0, ERR_INT_RANGE, constant);
                      WriteExprMsg ();
                    }

                  if (autorelocate)
                    if (postfixexpr->rangetype & SYMADDR)
                      {
                        /* Expression contains relocatable address */
                        constant = PC - curroffset;

                        if ((constant >= 0) && (constant <= 255))
                          {
                            *relocptr++ = (unsigned char) constant;
                            sizeof_reloctable++;
                          }
                        else
                          {
                            *relocptr++ = 0;
                            *relocptr++ = (unsigned short) (PC - curroffset) % 256U;
                            *relocptr++ = (unsigned short) (PC - curroffset) / 256U;
                            sizeof_reloctable += 3;
                          }

                        totaladdr++;
                        curroffset = (unsigned short)PC;
                      }
                  break;

                case 'L':
                  if (constant >= LONG_MIN && constant <= LONG_MAX)
                    for (i = 0; i < 4; i++)
                      {
                        *patchptr++ = constant & 255;
                        constant >>= 8;
                      }
                  else
                    {
                      ReportError (CURRENTFILE->fname, 0, ERR_INT_RANGE, constant);
                      WriteExprMsg ();
                    }
                  break;
                }
            }
          RemovePfixlist (postfixexpr);
        }
      else 
        {
          WriteExprMsg ();
        }
    }
  while (nextexpr < endexpr);
}



void 
WriteExprMsg (void)
{
  fprintf (errfile, "Error in expression %s\n\n", line);
}


void 
LinkModules (void)
{
    char fheader[9];
    size_t origin;
    struct module *lastobjmodule;
    symtable = listing = OFF;
    linkhdr = NULL;

    if (verbose)
	puts ("linking module(s)...\nPass1...");

    if (autorelocate == ON) {
	reloctable = (char *) xmalloc(32768U);
	relocptr = reloctable;
	relocptr += 4;	/* point at first offset to store */
	totaladdr = 0;
	sizeof_reloctable = 0;	/* relocation table, still 0 elements .. */
	curroffset = 0;
    }
    else
	reloctable = NULL;
  
    try {
	CURRENTMODULE = modulehdr->first;	/* begin with first module */
	lastobjmodule = modulehdr->last;	/* remember this last module, further modules are libraries */
	
	errfilename = xstrdup(CURRENTFILE->fname);
	strcpy (errfilename + strlen (errfilename) - 4, errext);	
					/* overwrite '_asm' extension with '_err' */

	if ((errfile = fopen(errfilename, "w")) == NULL) {	/* open error file */
	    ReportError(NULL, 0, ERR_FILE_OPEN, errfilename);	/* couldn't open error file */
	    throw(FatalErrorException, "cant open errfilename");
	}

	PC = 0;
	DefineDefSym(ASSEMBLERPC, PC, 0, &globalroot);	/* Create standard 'ASMPC' identifier */

	do {				/* link machine code & read symbols in all modules */
	    if (library) {
		CURRENTLIB = libraryhdr->firstlib;	/* begin library search  from first library for each
							* module */
		CURRENTLIB->nextobjfile = 8;		/* point at first library module (past header) */
	    }
	    CURRENTFILE->line = 0;	/* no line references on errors during link processing */

	    objfilename = xstrdup(CURRENTFILE->fname);
	    strcpy (objfilename + strlen (objfilename) - 4, objext);	
					/* overwrite '_asm' extension with * '_obj' */

	    /* open relocatable file for reading */
	    if ((z80asmfile = fopen (objfilename, "rb")) != NULL) {
		xfreadc(fheader, 8U, z80asmfile);		/* read first 6 chars from file into array */
		fheader[8] = '\0';
	    }
	    else {
		ReportError (NULL, 0, ERR_FILE_OPEN, objfilename);	/* couldn't open relocatable file */
		break;
	    }

	    /* compare header of file */
	    if (strcmp (fheader, Z80objhdr) != 0) {			
		ReportError (NULL, 0, ERR_NOT_OBJ_FILE, objfilename);	/* not a object     file */
		fclose (z80asmfile);
		z80asmfile = NULL;
		break;
	    }

	    origin = xfget_word(z80asmfile);

	    if (modulehdr->first == CURRENTMODULE) {		/* origin of first module */
		if (autorelocate)
		    CURRENTMODULE->origin = 0;			/* ORG 0 on auto relocation */
		else {
		    if (deforigin)
			CURRENTMODULE->origin = EXPLICIT_ORIGIN;	/* use origin from command line    */
		    else {
			CURRENTMODULE->origin = origin;
			if (CURRENTMODULE->origin == 65535U)
    			    DefineOrigin ();	/* Define origin of first module from the keyboard */
		    }
		}
		if (verbose == ON)
		    printf ("ORG address for code is %04lX\n", CURRENTMODULE->origin);
	    }
	    fclose (z80asmfile);

	    LinkModule (objfilename, 0);	/* link code & read name definitions */
	    xfree0(objfilename);		/* release allocated file name */
	    objfilename = NULL;

	    CURRENTMODULE = CURRENTMODULE->nextmodule;	/* get next module, if any */
	
	} while (CURRENTMODULE != lastobjmodule->nextmodule);	
					/* parse only object modules, not added library modules */

	if (verbose == ON)
	    printf ("Code size of linked modules is %d bytes\n", (int)CODESIZE);

	if (ASMERROR == OFF)
	    ModuleExpr ();		/*  Evaluate expressions in  all modules */

    }
    catch(EarlyReturnException) {
					/* do nothing, just for early return */
    }
    finally {
	ReleaseLinkInfo ();		/* Release module link information */
	if (errfile) {
	    fclose(errfile);
	    errfile = NULL;
	}
	if (TOTALERRORS == 0)
	    remove(errfilename);
	if (errfilename) {
	    xfree0(errfilename);
	    errfilename = NULL;
	}
	if (objfilename) {
	    xfree0(objfilename);
	    objfilename = NULL;
	}
    }
}




int 
LinkModule (char *filename, long fptr_base)
{
  long fptr_namedecl, fptr_modname, fptr_modcode, fptr_libnmdecl;
  size_t size;
  int flag = 0;

  z80asmfile = fopen (filename, "rb");	/* open object file for reading */
  fseek (z80asmfile, fptr_base + 10U, SEEK_SET);

  fptr_modname = xfget_long(z80asmfile);		/* get file pointer to module name */
  xfget_long(z80asmfile);			/* get file pointer to expression declarations */
  fptr_namedecl = xfget_long(z80asmfile);	/* get file pointer to name declarations */
  fptr_libnmdecl = xfget_long(z80asmfile);	/* get file pointer to library name declarations */
  fptr_modcode = xfget_long(z80asmfile);		/* get file pointer to module code */

  if (fptr_modcode != -1)
    {
      fseek (z80asmfile, fptr_base + fptr_modcode, SEEK_SET);	/* set file pointer to module code */
      size = xfget_word(z80asmfile);

      /* BUG_0008 : fix size, if a zero was written, the moudule is actually 64K */
      if (size == 0) 
	  size = 0x10000;

      if (CURRENTMODULE->startoffset + size > MAXCODESIZE)
        {
          ReportError (filename, 0, ERR_MAX_CODESIZE);
          return 0;
        }
      else
        xfreadc(codearea + CURRENTMODULE->startoffset, size, z80asmfile);	/* read module code */

      if (CURRENTMODULE->startoffset == CODESIZE)
        CODESIZE += size;	/* a new module has been added */
    }

  if (fptr_namedecl != -1)
    {
      fseek (z80asmfile, fptr_base + fptr_namedecl, SEEK_SET);	/* set file pointer to point at name
                                                                 * declarations */
      if (fptr_libnmdecl != -1)
        ReadNames (fptr_namedecl, fptr_libnmdecl);	/* Read symbols until library declarations */
      else
        ReadNames (fptr_namedecl, fptr_modname);	/* Read symbol suntil module name */
    }

  fclose (z80asmfile);

  if (fptr_libnmdecl != -1)
    {
      if (library)
        {			/* search in libraries, if present */
          flag = LinkLibModules (filename, fptr_base, fptr_libnmdecl, fptr_modname);	/* link library modules */

          if (!flag)
            return 0;
        }
    }

  return LinkTracedModule (filename, fptr_base);	/* Remember module for pass2 */
}




int 
LinkLibModules (char *filename, long fptr_base, long nextname, long endnames)
{
  long len;
  char *modname;

  do
    {
      z80asmfile = fopen (filename, "rb");	/* open object file for reading */
      fseek (z80asmfile, fptr_base + nextname, SEEK_SET);	/* set file pointer to point at library name
                                                             * declarations */
      ReadName ();		/* read library reference name */
      fclose (z80asmfile);

      len = strlen (line);
      nextname += 1 + len;	/* remember module pointer to next name in this   object module */
      if (FindSymbol (line, globalroot) == NULL)
        {
	  modname = xstrdup(line);
	  try {
	      SearchLibraries (modname);	/* search name in libraries */
	  }
	  finally {
	      xfree0(modname);	/* remove copy of module name */
	  }
        }                          
    }
  while (nextname < endnames);

  return 1;
}




void 
SearchLibraries (char *modname)
{

  int i;
 

  for (i = 0; i < 2; i++)
    {				/* Libraries searched in max. 2 passes */
      while (CURRENTLIB != NULL)
        {
          if (SearchLibfile (CURRENTLIB, modname))
            return;

          CURRENTLIB = CURRENTLIB->nextlib;
          if (CURRENTLIB != NULL)
            if (CURRENTLIB->nextobjfile != 8)
              CURRENTLIB->nextobjfile = 8;	/* search at start of next lib */
        }

      /* last library read ... */
      CURRENTLIB = libraryhdr->firstlib;	/* start at the beginning of the first module */
      CURRENTLIB->nextobjfile = 8;		/* in the first library */
    }
}



int 
SearchLibfile (struct libfile *curlib, char *modname)
{
  long currentlibmodule, modulesize;
  int ret;
  char *mname;

  z80asmfile = fopen (curlib->libfilename, "rb");

  while (curlib->nextobjfile != -1)
    {				/* search name in all available library modules */
      do
        {			/* point at first available module in library */
          fseek (z80asmfile, curlib->nextobjfile, SEEK_SET);	/* point at beginning of a module */
          currentlibmodule = curlib->nextobjfile;
          curlib->nextobjfile = xfget_long(z80asmfile);	/* get file pointer to next module in library */
          modulesize = xfget_long(z80asmfile);	/* get size of current module */
        }
      while (modulesize == 0 && curlib->nextobjfile != -1);

      if (modulesize != 0)
        {
          if ( ( mname = CheckIfModuleWanted(z80asmfile, currentlibmodule, modname) ) != NULL )
            {
		try {
		  fclose (z80asmfile);
		  ret =  LinkLibModule (curlib, currentlibmodule + 4 + 4, mname);
		} 
		finally {
		  xfree0(mname);
		}
                return ret;
            }
          else if ( sdcc_hacks == ON && modname[0] == '_' && ( mname = CheckIfModuleWanted(z80asmfile, currentlibmodule, modname + 1) ) != NULL )
            {
		try {
		  fclose (z80asmfile);
		  ret =  LinkLibModule (curlib, currentlibmodule + 4 + 4, mname);
		}
		finally {
		  xfree0(mname);
		}
                return ret;
            }
        }
    }

  fclose (z80asmfile);
  return 0;
}


/** \brief Check to see if a library module is required
 *
 *  \param z80asmfile - File to read from
 *  \param currentlibmodule - Current offset in file
 *  \param modname - Module/symbol to search for

 */
static char *
CheckIfModuleWanted(FILE *z80asmfile, long currentlibmodule, char *modname)
{
    long fptr_mname, fptr_expr, fptr_name, fptr_libname;
    char *mname;
    char *name;
    enum flag found = OFF;


    /* found module name? */
    fseek (z80asmfile, currentlibmodule + 4 + 4 + 8 + 2, SEEK_SET);	/* point at module name  file
									* pointer */
    fptr_mname = xfget_long(z80asmfile);	/* get module name file  pointer   */
    fptr_expr = xfget_long(z80asmfile);
    fptr_name = xfget_long(z80asmfile);
    fptr_libname = xfget_long(z80asmfile);
    fseek (z80asmfile, currentlibmodule + 4 + 4 + fptr_mname, SEEK_SET);	/* point at module name  */
    mname = xstrdup(ReadName ());			/* read module name */
    try {
	if (strcmp (mname, modname) == 0) {
	    found = ON;
	}
	else {
	    /* We didn't find the module name, lets have a look through the exported symbol list */
	    if ( fptr_name != 0 ) {
		long end = fptr_libname;
		long red = 0;
		if ( fptr_libname == -1 ) {
		    end = fptr_mname;
		}
		/* Move to the name section */
		fseek(z80asmfile,currentlibmodule + 4 + 4 + fptr_name,SEEK_SET);
		red = fptr_name;
		while ( ! found && red < end ) {
		    char scope, type;
		    long temp;

		    scope = xfgetc(z80asmfile); red++;
		    type = xfgetc(z80asmfile); red++;
		    temp = xfget_long(z80asmfile); red += 4;
		    name = ReadName();
		    red += strlen(name);
		    red++; /* Length byte */
		    if ( (scope == 'X' || scope == 'G') && strcmp(name, modname) == 0 ) {
			found = ON;
		    }
		}
	    }
	}
    }
    catch(RuntimeException) {
	xfree0(mname);
	rethrow("");
    }

    if (!found) {
	xfree0(mname);
	mname = NULL;
    }
    return mname;
}

int 
LinkLibModule (struct libfile *library, long curmodule, char *modname)
{
    struct module *tmpmodule;
    int flag;

    tmpmodule = CURRENTMODULE;	/* remember current module */

    CURRENTMODULE = NewModule();
    CURRENTMODULE->mname = xstrdup(modname);	/* get a copy of module name */
						/* create new module for library */
    CURRENTFILE = Newfile(NULL, library->libfilename);	/* filename for 'module' */

    if (verbose)
	printf ("Linking library module <%s>\n", modname);

    flag = LinkModule (library->libfilename, curmodule);	/* link   module & read names */

    CURRENTMODULE = tmpmodule;	/* restore previous current module */
    return flag;
}



char *
ReadName (void)
{
  size_t strlength;

  strlength = xfgetc(z80asmfile);
  xfreadc(line, strlength, z80asmfile);	/* read   name */
  line[strlength] = '\0';

  return line;
}



void 
ModuleExpr (void)
{
  long fptr_namedecl, fptr_modname, fptr_exprdecl, fptr_libnmdecl;
  long fptr_base;
  struct linkedmod *curlink;

  if (verbose)
    puts ("Pass2...");

  curlink = linkhdr->firstlink;
  do
    {
      CURRENTMODULE = curlink->moduleinfo;
      fptr_base = curlink->modulestart;

      if ((z80asmfile = fopen (curlink->objfilename, "rb")) != NULL)
        {			/* open relocatable file for reading */
          fseek (z80asmfile, fptr_base + 10, SEEK_SET);		/* point at module name  pointer   */
          fptr_modname = xfget_long(z80asmfile);		/* get file pointer to module name */
          fptr_exprdecl = xfget_long(z80asmfile);	/* get file pointer to expression declarations */
          fptr_namedecl = xfget_long(z80asmfile);	/* get file pointer to name declarations */
          fptr_libnmdecl = xfget_long(z80asmfile);	/* get file pointer to library name declarations */
        }
      else
        {
          ReportError (NULL, 0, ERR_FILE_OPEN, curlink->objfilename);		/* couldn't open relocatable file */
          throw(FatalErrorException, "ModuleExpr failed open objfile");
        }

      if (fptr_exprdecl != -1)
        {
          fseek (z80asmfile, fptr_base + fptr_exprdecl, SEEK_SET);
          if (fptr_namedecl != -1)
            ReadExpr (fptr_exprdecl, fptr_namedecl);	/* Evaluate until beginning of name
                                                         * declarations     */
          else if (fptr_libnmdecl != -1)
            ReadExpr (fptr_exprdecl, fptr_libnmdecl);	/* Evaluate until beginning of library
                                                         * reference declarations */
          else
            ReadExpr (fptr_exprdecl, fptr_modname);	/* Evaluate until beginning of module name */
        }
      fclose (z80asmfile);

      z80asmfile = NULL;
      curlink = curlink->nextlink;
    }
  while (curlink != NULL);
}



void 
CreateBinFile (void)
{
  char *tmpstr;
  char binfilenumber = '0';
  FILE *binaryfile;
  unsigned short codeblock, offset;

  if (expl_binflnm == ON)
    /* use predined output filename from command line */
    tmpstr = binfilename;
  else
    { 
      /* create output filename, based on project filename */
      tmpstr = modulehdr->first->cfile->fname;	/* get source filename from first module */
      if (codesegment == ON && CODESIZE > 16384)
        strcpy (tmpstr + strlen (tmpstr) - 4, segmbinext);	/* replace '.asm' with '.bn0' extension */
      else
        strcpy (tmpstr + strlen (tmpstr) - 4, binext);	/* replace '.asm' with '.bin' extension */
    }

  binaryfile = fopen (tmpstr, "wb");	/* binary output to srcfilename.bin */
  if (binaryfile != NULL)
    {
      if (autorelocate == ON && totaladdr != 0)
	{
	  xfwritec(reloc_routine, sizeof_relocroutine, binaryfile);	/* relocate routine */
	  *(reloctable + 0) = (unsigned short) totaladdr % 256U;
	  *(reloctable + 1) = (unsigned short) totaladdr / 256U;	/* total of relocation elements */
	  *(reloctable + 2) = (unsigned short) sizeof_reloctable % 256U;
	  *(reloctable + 3) = (unsigned short) sizeof_reloctable / 256U;/* total size of relocation table elements */

	  xfwritec(reloctable, sizeof_reloctable + 4, binaryfile);	/* write relocation table, inclusive 4 byte header */
	  printf ("Relocation header is %d bytes.\n", (int)(sizeof_relocroutine + sizeof_reloctable + 4));
	  xfwritec(codearea, CODESIZE, binaryfile);	/* write code as one big chunk */
	  fclose (binaryfile);
	}
      else if (codesegment == ON && CODESIZE > 16384)
	{
	  fclose (binaryfile);
	  offset = 0;
	  do
	    {
	      codeblock = (CODESIZE / 16384U) ? 16384U : CODESIZE % 16384U;
	      CODESIZE -= codeblock;
	      tmpstr[strlen (tmpstr) - 1] = binfilenumber++;	/* path code file with number */
	      binaryfile = fopen (tmpstr, "wb");

	      if (binaryfile != NULL)
		{
		  xfwritec(codearea + offset, codeblock, binaryfile);	/* code in 16K chunks */
		  fclose (binaryfile);
		}

	      offset += codeblock;
	    }
	  while (CODESIZE);
	}
      else
	{
	  xfwritec(codearea, CODESIZE, binaryfile);	/* write code as one big chunk */
	  fclose (binaryfile);
	}

      if (verbose)
	puts ("Code generation completed.");
    }
  else {
    ReportError (NULL, 0, ERR_FILE_OPEN, tmpstr);
    throw(FatalErrorException, "CreateBinFile failed open binfile");
  }
}



void 
CreateLib (void)
{
    long Codesize;
    FILE *objectfile = NULL;
    long fptr;
    char *filebuffer = NULL, *fname = NULL;

    if (verbose)
	puts ("Creating library...");

    CURRENTMODULE = modulehdr->first;

    errfilename = xstrdup(libfilename);
    strcpy (errfilename + strlen (errfilename) - 4, errext);	/* overwrite '_lib' extension with '_err' */

    try {
	if ((errfile = fopen (errfilename, "w")) == NULL) {
					/* open error file */
	    ReportError (NULL, 0, ERR_FILE_OPEN, errfilename);
	    throw(FatalErrorException, "cannot open errfilename");
	}

	do {
	    fname = CURRENTFILE->fname;
	    strcpy (fname + strlen (fname) - 4, objext);	/* overwrite '_asm' extension with '_obj' */

	    if ((objectfile = fopen (CURRENTFILE->fname, "rb")) == NULL) {
		ReportError (NULL, 0, ERR_FILE_OPEN, CURRENTFILE->fname);
		throw(FatalErrorException, "cannot open objfile");
	    }

	    fseek(objectfile, 0L, SEEK_END);	/* file pointer to end of file */
	    Codesize = ftell(objectfile);
	    fseek(objectfile, 0L, SEEK_SET);	/* file pointer to start of file */
        	
	    filebuffer = (char *) xmalloc((size_t) Codesize);
	    xfreadc(filebuffer, Codesize, objectfile);	/* load object file */
	    fclose (objectfile);
	    objectfile = NULL;

	    if (memcmp (filebuffer, Z80objhdr, 8U) != 0) {
		ReportError (NULL, 0, ERR_NOT_OBJ_FILE, CURRENTFILE->fname);
		break;
	    }

	    if (verbose)
		printf ("<%s> module at %04lX.\n", CURRENTFILE->fname, ftell (libfile));

	    if (CURRENTMODULE->nextmodule == NULL)
		xfput_long(-1, libfile);	/* this is the last module */
	    else {
		fptr = ftell (libfile) + 4 + 4;
		xfput_long(fptr + Codesize, libfile);	/* file pointer to next module */
	    }
		       
	    xfput_long(Codesize, libfile);	/* size of this module */
	    xfwritec(filebuffer, (size_t) Codesize, libfile);	/* write module to library */
	    xfree0(filebuffer);

	    CURRENTMODULE = CURRENTMODULE->nextmodule;
	} while (CURRENTMODULE != NULL);
    }
    catch(EarlyReturnException) {
					/* do nothing, just for early return */
    }
    finally {
	if (errfile) {
	    fclose (errfile);
	    errfile = NULL;
	}
	if (errfilename) {
	    if (ASMERROR == OFF)
		remove (errfilename);	/*    no errors */
	    xfree0(errfilename);
	}
	if (objectfile) {
	    fclose(objectfile);
	    objectfile = NULL;
	}
	if (filebuffer) {
	    xfree0(filebuffer);
	}
    }
}



int 
LinkTracedModule (char *filename, long baseptr)
{
    struct linkedmod *newm;
    char *fname;

    if (linkhdr == NULL) {
	linkhdr = xcalloc_struct(struct linklist);
	linkhdr->firstlink = NULL;
	linkhdr->lastlink = NULL;	/* Library header initialised */
    }

    fname = xstrdup(filename);		/* get a copy module file name */
    try {
	newm = xcalloc_struct(struct linkedmod);
	newm->nextlink = NULL;
	newm->objfilename = fname;
	newm->modulestart = baseptr;
	newm->moduleinfo = CURRENTMODULE;   /* pointer to current (active) module structure   */

    }
    catch(RuntimeException) {
	xfree0(fname);
	rethrow("");
    }

    if (linkhdr->firstlink == NULL) {
	linkhdr->firstlink = newm;
	linkhdr->lastlink = newm;	/* First module trace information */
    }
    else {
	linkhdr->lastlink->nextlink = newm;	/* current/last linked module points now at new current */
	linkhdr->lastlink = newm;		/* pointer to current linked module updated */
    }

    return 1;
}




void 
DefineOrigin (void)
{
  printf ("ORG not yet defined!\nPlease enter as hexadecimal: ");
  scanf ("%lx", &modulehdr->first->origin);
}



void 
CreateDeffile (void)
{
    char *globaldefname;

    /* use first module filename to create global definition file */
    globaldefname = xstrdup(modulehdr->first->cfile->fname);
    try {
	strcpy (globaldefname + strlen (globaldefname) - 4, defext);	/* overwrite '_asm' extension with
									    * '_def' */
	if ((deffile = fopen (globaldefname, "w")) == NULL)
	{			/* Create DEFC file with global label declarations */
	    ReportError (NULL, 0, ERR_FILE_OPEN, globaldefname);	/* not fatal */
	    globaldef = OFF;
	}
    }
    finally {
	xfree0(globaldefname);
    }
}


void 
WriteMapFile (void)
{
    avltree *maproot = NULL, *newmaproot = NULL;
    struct module *cmodule;
    char *mapfilename;

    cmodule = modulehdr->first;	/* begin with first module */

    mapfilename = xstrdup(cmodule->cfile->fname);
    strcpy (mapfilename + strlen (mapfilename) - 4, mapext);	/* overwrite '_asm' extension with '_map' */
    try {
	if ((mapfile = fopen (mapfilename, "w")) != NULL) {	/* Create MAP file */
	    if (verbose)
		puts ("Creating map...");

	    do {
		move (&cmodule->localroot, &maproot, (int (*)(void*,void*)) cmpidstr);        /* move all  local address symbols alphabetically */
		cmodule = cmodule->nextmodule;	/* alphabetically */
	    }
	    while (cmodule != NULL);

	    move (&globalroot, &maproot, (int (*)(void*,void*)) cmpidstr);    /* move all global address symbols alphabetically */

	    if (maproot == NULL) {
		fputs ("None.\n", mapfile);
	    }
	    else {
		inorder (maproot, (void (*)(void*)) WriteMapSymbol);  /* Write map symbols alphabetically */
		move (&maproot, &newmaproot, (int (*)(void*,void*)) cmpidval);        /* then re-order symbols numerically */
		fputs ("\n\n", mapfile);

		inorder (newmaproot, (void (*)(void*)) WriteMapSymbol);       /* Write map symbols numerically */
		deleteall (&newmaproot, (void (*)(void*)) FreeSym);   /* then release all map symbols */
	    }

	    fclose (mapfile);
	}
	else {
	    ReportError (NULL, 0, ERR_FILE_OPEN, mapfilename);	    /* not fatal */
	}
    }
    finally {
	xfree0(mapfilename);
    }
}



void 
WriteMapSymbol (symbol * mapnode)
{
  int tabulators, space;

  if (mapnode->type & SYMADDR)
    {
      fprintf (mapfile, "%s", mapnode->symname);
      space = COLUMN_WIDTH - strlen (mapnode->symname);
      for (tabulators = space % TAB_DIST ? space / TAB_DIST + 1 : space / TAB_DIST;
	   tabulators > 0; tabulators--)
	xfputc('\t', mapfile);

      if (autorelocate)
	fprintf (mapfile, "= %04lX, ", sizeof_relocroutine + sizeof_reloctable + 4 + mapnode->symvalue);
      else
	fprintf (mapfile, "= %04lX, ", mapnode->symvalue);

      if (mapnode->type & SYMLOCAL)
	xfputc('L', mapfile);
      else
	xfputc('G', mapfile);

      fprintf (mapfile, ": %s\n", mapnode->owner->mname);
    }
}



void 
WriteGlobal (symbol * node)
{
  int tabulators, space;

  if ((node->type & SYMTOUCHED) && (node->type & SYMADDR) &&
      (node->type & SYMXDEF) && !(node->type & SYMDEF))
    {
      /* Write only global definitions - not library routines     */
      fprintf (deffile, "DEFC %s", node->symname);

      space = COLUMN_WIDTH - 5 - strlen (node->symname);
      for (tabulators = space % TAB_DIST ? space / TAB_DIST + 1 : space / TAB_DIST; tabulators > 0; tabulators--)
	xfputc('\t', deffile);

      fprintf (deffile, "= $%04lX; ", node->symvalue + modulehdr->first->origin + CURRENTMODULE->startoffset);
      fprintf (deffile, "Module %s\n", node->owner->mname);
    }
}



void 
ReleaseLinkInfo (void)
{
  struct linkedmod *m, *n;

  if (linkhdr == NULL)
    return;

  m = linkhdr->firstlink;

  while (m != NULL) {		    /* move test to start in case list is empty */
      if (m->objfilename != NULL)
	xfree0(m->objfilename);

      n = m->nextlink;
      xfree0(m);
      m = n;
  }

  xfree0(linkhdr);

  linkhdr = NULL;
}


/*
 * Local Variables:
 *  indent-tabs-mode:nil
 *  require-final-newline:t
 *  c-basic-offset: 2
 *  eval: (c-set-offset 'case-label 0)
 *  eval: (c-set-offset 'substatement-open 2)
 *  eval: (c-set-offset 'access-label 0)
 *  eval: (c-set-offset 'class-open 2)
 *  eval: (c-set-offset 'class-close 2)
 * End:
 */
