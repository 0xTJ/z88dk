/* generated by {{ prog }} {{ args.join(' ') }} */

/* includes */
#include "memalloc.h"   			/* before any other include */

#include <stdlib.h>
#include <stdio.h>
#include <glib.h>

#include "init.h"
#undef main							/* define main only in user code */

/* data types */
typedef struct ObjectRegister_store
{
	void (*delete_func)(void **);	/* delete function pointer, NULL if no auto-delete */
} ObjectRegister_store;

#define STORE_ADDR(data)	(((char *)(data))  - sizeof(void*))
#define DATA_ADDR(store)	(((char *)(store)) + sizeof(void*))

/* data store for each managed object */
{{ FOR i IN init_struct }}
typedef struct {{ i.struct }}_store
{
	void (*delete_func)({{ i.struct }} **);	/* delete function pointer, NULL if no auto-delete */
	{{ i.struct }} data;
} {{ i.struct }}_store;
{{ END }}

/* global data */
static GList *objects;				/* all registered objects for cleanup at end */

/* declare functions */
extern int 	user_main(int argc, char *argv[]);
static void init();
static void xatexit(void (*fini)(void));
static void objects_init(void);
static void objects_fini(void);
static void register_object(void *object);
static void unregister_object(void *object);
static ObjectRegister_store *first_autodelete(void);

{{ FOR i IN init_struct }}
/* {{ i.struct }}: create, destroy, set/clear autodelete */
{{ i.struct }} * new_{{ i.struct }} ( {{ i.methods.new.decl }} )
{
	{{ i.struct }}_store * self_store = g_slice_new0( {{ i.struct }}_store );
	{{ i.struct }}       * self       = ({{ i.struct }} *) DATA_ADDR( self_store );
	
	autodelete_{{ i.struct }}( self, TRUE );
{{   IF i.methods.init.func }}
	{{ i.methods.init.func }}( {{ i.methods.init.call }} );
{{   END }}
	register_object( (void*) self_store );

	return self;
}

void delete_{{ i.struct }} ( {{ i.struct }} **pself )
{
	{{ i.struct }}_store * self_store = ({{ i.struct }}_store *) STORE_ADDR( *pself );
	
	unregister_object( (void*) self_store );
{{   IF i.methods.fini.func }}
	{{ i.methods.fini.func }}( *pself );
{{   END }}
	g_slice_free( {{ i.struct }}_store, self_store );

	*pself = NULL;
}

void autodelete_{{ i.struct }} ( {{ i.struct }} *self, BOOL autodelete )
{
	{{ i.struct }}_store * self_store = ({{ i.struct }}_store *) STORE_ADDR( self );
	
	self_store->delete_func = autodelete ? delete_{{ i.struct }} : NULL;
}
{{ END }}

/* get first object in register with autodelete set */
static ObjectRegister_store *first_autodelete(void)
{
	GList *object;
	ObjectRegister_store *data;
	
	for ( object = g_list_first(objects); object; object = g_list_next(object) )
	{
		data = (ObjectRegister_store *) object->data;
		if ( data->delete_func )
			return data;
	}
	return NULL;		
}

/* initialize object register */
static void objects_init(void)
{
	static BOOL initialized = FALSE;

	if ( ! initialized )
	{
		xatexit( objects_fini );
		initialized = TRUE;
	}
}

/* cleanup object register, release all memory */
static void objects_fini(void)
{
	ObjectRegister_store *store;
	void                 *data;
	
	/* search list from start on each iteration, as list may be modified by object delete */
	while ( (store = first_autodelete()) != NULL )
	{
		data = DATA_ADDR(store);
		(store->delete_func)( &data );
	}
	g_list_free( objects );
	objects = NULL;
}

/* register object */
static void register_object ( void *object )
{
	objects_init();
	objects = g_list_prepend( objects, object );
}

/* unregister object */
static void unregister_object ( void *object )
{
	objects_init();
	objects = g_list_remove( objects, object );
}

/* register atexit(), die on error */
static void xatexit(void (*fini)(void))
{
	if (atexit(fini))
	{
		fprintf(stderr, "atexit() failed\n");
		exit(1);
	}
}

/* initialize all modules */
static void init()
{
{{ FOREACH i IN init_module }}
  {{ IF i.type == 'init' }}
	{{ i.func }}();
  {{ ELSE }}
	xatexit( {{ i.func }} );
  {{ END }}
{{ END }}
}

/* new main function to init and call user main */
int main(int argc, char *argv[])
{
    init();
    return user_main(argc, argv);
}
