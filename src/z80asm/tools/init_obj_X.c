/* generated by {{ prog }} {{ args.join(' ') }} */

/* includes */
#include "memalloc.h"   			/* before any other include */

#include "init.h"

{{ FOR i IN init_struct }}
{{   IF i.file == file }}
/* data store for managed object */
typedef struct {{ i.struct }}_store
{
	void (*delete_func)({{ i.struct }} **);	/* delete function pointer, NULL if no auto-delete */
	{{ i.struct }} data;
} {{ i.struct }}_store;

/* {{ i.struct }}: create, destroy, set/clear autodelete */
{{ i.struct }} * new_{{ i.struct }} ( {{ i.methods.new.decl }} )
{
	{{ i.struct }}_store *self_store = g_slice_new0( {{ i.struct }}_store );
	{{ i.struct }} *self = ({{ i.struct }} *) OBJREG_DATA_ADDR( self_store );
	
	autodelete_{{ i.struct }}( self, TRUE );
{{   IF i.methods.init.func }}
	{{ i.methods.init.func }}( {{ i.methods.init.call }} );
{{   END }}
	register_object( (void*) self_store );

	return self;
}

void delete0_{{ i.struct }} ( {{ i.struct }} **pself )
{
	if ( *pself )
	{
		{{ i.struct }}_store *self_store = 
				({{ i.struct }}_store *) OBJREG_STORE_ADDR( *pself );
		
		unregister_object( (void*) self_store );
{{   IF i.methods.fini.func }}
		{{ i.methods.fini.func }}( *pself );
{{   END }}
		g_slice_free( {{ i.struct }}_store, self_store );

		*pself = NULL;
	}
}

void delete_{{ i.struct }} ( {{ i.struct }} *self )
{
	delete0_{{ i.struct }}( &self );
}

void autodelete_{{ i.struct }} ( {{ i.struct }} *self, BOOL autodelete )
{
	{{ i.struct }}_store *self_store = 
			({{ i.struct }}_store *) OBJREG_STORE_ADDR( self );
	
	self_store->delete_func = autodelete ? delete0_{{ i.struct }} : NULL;
}

{{   END }}
{{ END }}
