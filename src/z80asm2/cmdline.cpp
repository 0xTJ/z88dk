/* Generated by re2c */
//-----------------------------------------------------------------------------
// re2c source to parse command line arguments
// Copyright (c) Paulo Custodio, 2015-2016
// License: http://www.perlfoundation.org/artistic_license_2_0
//-----------------------------------------------------------------------------

#define YYMAXFILL 7

enum YYCONDTYPE {
			yycinit,
};


#include <iostream>
#include <fstream>
#include <string>
#include "cmdline.hpp"
#include "messages.hpp"
#include "util.hpp"

static void usage()
{
	g_messages.information(MES_COPYRIGHT);
	g_messages.plaintext("");
	g_messages.information(MES_USAGE);
}

static void help()
{
	g_messages.information(MES_COPYRIGHT);
	g_messages.plaintext("");
	g_messages.information(MES_USAGE);
	g_messages.plaintext("");
	g_messages.information(MES_HELP);
}

// append a file or the list of files from a '@'-list into the passed vector
static bool insert_file(std::string filename, 
						std::vector<std::string> & list)
{
	std::size_t size = filename.size();
	char prefix = (size == 0) ? '\0' : filename[0];
	
	if (size == 0 || prefix == '#' || prefix == ';') {
		// ignore
	}
	else if (prefix == '@') {
		filename.erase(0, 1);					// remove '@'
		
		std::ifstream file(filename.c_str());	// open list file
		if (!file.good()) {
			g_errors.error(ERR_READ_FILE, filename);
			return false;
		}
		else {
			g_errors.push_context(ERR_READ_CONTEXT, filename);
			{				
				std::string line;
				while (safeGetline(file, line)) 
					insert_file(line, list);
			}
			g_errors.pop_context();
		}
	}
	else {
		list.push_back(filename);
	}
	
	return true;
}

// parse command line, accumulate arguments and options in out_args
// return false if no further processing should be done - error or usage/help
bool parse_cmdline(int argc, char *argv[], args_t& out_args)
{
	int arg;
	
	if (argc <= 1) {
		usage();
		return false;
	}

	// parse each argument
	for (arg = 1; arg < argc; arg++) {
		const char *YYCURSOR = argv[arg];
		const char *YYMARKER;
		//const char *YYCTXMARKER;
		int cond = yycinit;
		
{
			char yych;
			switch (cond) {
			case yycinit: goto yyc_init;
			}
/* *********************************** */
yyc_init:
			yych = *YYCURSOR;
			switch (yych) {
			case '\n':			goto yy5;
			case '-':			goto yy7;
			default:			goto yy3;
			}
yy3:
			++YYCURSOR;
			{ 	if (!insert_file(YYCURSOR - 1, out_args.files))
								return false;
							continue; 
						}
yy5:
			++YYCURSOR;
			{ 	g_errors.error(ERR_INVALID_OPTION, argv[arg]); 
							return false; 
						}
yy7:
			yych = *(YYMARKER = ++YYCURSOR);
			switch (yych) {
			case '-':			goto yy9;
			case 'h':			goto yy11;
			default:			goto yy8;
			}
yy8:
			{ 	g_errors.error(ERR_INVALID_OPTION, argv[arg]); 
							return false; 
						}
yy9:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'h':			goto yy12;
			default:			goto yy10;
			}
yy10:
			YYCURSOR = YYMARKER;
			goto yy8;
yy11:
			yych = *++YYCURSOR;
			if (yych <= 0x00) goto yy13;
			goto yy10;
yy12:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'e':			goto yy15;
			default:			goto yy10;
			}
yy13:
			++YYCURSOR;
			{ 	help(); 
							return false; 
						}
yy15:
			yych = *++YYCURSOR;
			switch (yych) {
			case 'l':			goto yy16;
			default:			goto yy10;
			}
yy16:
			++YYCURSOR;
			switch ((yych = *YYCURSOR)) {
			case 'p':			goto yy11;
			default:			goto yy10;
			}
}

	}
	return true;
}
