#!perl
#------------------------------------------------------------------------------
# Build messages.cpp and messages.hpp with error and information messages
# Copyright (c) Paulo Custodio, 2015-2016
# License: http://www.perlfoundation.org/artistic_license_2_0
#------------------------------------------------------------------------------

use strict;
use warnings;
use File::Basename;
use Path::Tiny;
use Data::Dump qw( quote );
{ package Message; use Object::Tiny qw( id is_error text ); }

my $prog = basename($0, ".pl");
my $PROG = uc($prog);

#------------------------------------------------------------------------------
# read messages from __DATA__
#------------------------------------------------------------------------------
my @messages;
while (<DATA>) {
	chomp;
	/^#/ and next;
	/\S/ or next;
	if (my($id, $text) = /^([a-z_]\w*)\s*=(.*)/i) {
		my $is_error = $id =~ /^ERR_/;
		push @messages, Message->new(id => $id, is_error => $is_error, 
									text => $text);
	}
	elsif (@messages && (($text) = /^\s*=(.*)/i)) {
		$messages[-1]->{text} .= "\n".$text;
	}
	else {
		die "Syntax error in message '$_'";
	}	
}

#------------------------------------------------------------------------------
# write .hpp
#------------------------------------------------------------------------------
path("$prog.hpp")->spew(<<END,
// File generated by $prog.pl, do not edit

#ifndef ${PROG}_HPP
#define ${PROG}_HPP

#include "message_handler.hpp"

// information and error messages channels
extern stlplus::message_handler g_messages;
extern stlplus::message_handler g_errors;

// message ids
END
(map {"extern const char *".$_->id.";\n"} @messages), <<END,

// setup messages
extern void init_$prog();

#endif // ndef ${PROG}_HPP
END
);
print "+ $prog.hpp\n";

#------------------------------------------------------------------------------
# write .cpp
#------------------------------------------------------------------------------
path("$prog.cpp")->spew(<<END,
// File generated by $prog.pl, do not edit

#include <iostream>
#include "$prog.hpp"

stlplus::message_handler g_messages(std::cout, 0);	// infinite error limit
stlplus::message_handler g_errors(std::cerr, 0);	// infinite error limit

END
(map {"const char *".$_->id." = \"".$_->id."\";\n"} @messages), <<END,

void init_$prog() {
END
(map {($_->is_error ? "g_errors" : "g_messages").
	  ".add_message(".$_->id.", ".
	  quote_c($_->text).
	  ");\n"} @messages), <<END,
}

END
);
print "+ $prog.cpp\n";

sub quote_c {
	my($text) = @_;
	$text = quote($text);
	$text =~ s/\\([\@\$])/$1/g;			# unquote perl '@' and '$'
	$text =~ s/(\\n)/$1\"\n\"/g;	# split long C lines
	return $text
}

#------------------------------------------------------------------------------
# input data
#------------------------------------------------------------------------------
__DATA__
# list of messages - ID =message
MES_COPYRIGHT	=Z80 Module Assembler 3.0-alpha, (c) Paulo Custodio 2011-2016
MES_USAGE		=Usage: z80asm2 [options] { \@<modulefile> | <filename> }...
MES_HELP		=Using z80asm2:
				=
				=  To assemble 'fred.asm' use 'fred' or 'fred.asm'
				=
				=  <modulefile> contains list of file names of all modules to be linked,
				=  one file per line. 
				=  Empty lines or lines starting with ';' or '#' are ignored.
				=  Lines starting with '\@' are expanded recursively.
				=
				=  File types recognized or created by z80asm:
				=    .asm = source file (default), or alternative -e<ext>
				=    .obj = object file (default), or alternative -M<ext>
				=    .lis = list file
				=    .bin = Z80 binary file
				=    .sym = symbols file
				=    .map = map file
				=    .reloc = reloc file
				=    .def = global address definition file
				=    .err = error file
				=
				=Help Options:
				=  -h, --help             Show help options
				=  -v, --verbose          Be verbose
				=
				=Input / Output File Options:
				=  -e, --asm-ext=EXT      Assembly file extension excluding '.'
				=  -M, --obj-ext=EXT      Object file extension excluding '.'
				=  -o, --output=FILE      Output binary file
				=
				=Code Generation Options:
				=  --RCMX000              Assemble for RCM2000/RCM3000 series of Z80-like CPU
				=  --ti83plus             Interpret 'Invoke' as RST 28h
				=  --IXIY                 Swap IX and IY registers
				=  -C, --line-mode        Enable LINE directive
				=
				=Environment:
				=  -I, --inc-path=PATH    Add directory to include search path
				=  -L, --lib-path=PATH    Add directory to library search path
				=  -D, --define=SYMBOL    Define a static symbol
				=
				=Libraries:
				=  -x, --make-lib=FILE    Create a library file.lib
				=  -i, --use-lib=FILE     Link library file.lib
				=
				=Binary Output:
				=  -b, --make-bin         Assemble and link/relocate to file.bin
				=  --split-bin            Create one binary file per section
				=  -d, --date-stamp       Assemble only updated files
				=  -r, --origin=ADDR      Relocate binary file to given address (decimal or hex)
				=  -R, --relocatable      Create relocatable code
				=  --reloc-info           Geneate binary file relocation information
				=
				=Output File Options:
				=  -s, --symtable         Create symbol table file.sym
				=  -l, --list             Create listing file.lis
				=  -m, --map              Create address map file.map
				=  -g, --globaldef        Create global definition file.def

MES_PARSING_FILE	=parsing file '@0'
ERR_INVALID_OPTION	=invalid option '@0', run z80asm2 -h for help
ERR_READ_FILE		=cannot read file '@0'
ERR_READ_CONTEXT	=while reading file '@0'
ERR_RECURSIVE_INCLUDE=recursive include reading '@0'
ERR_SYNTAX			=syntax error
ERR_RANGE			=number range
