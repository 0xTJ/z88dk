	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_ne
	ld	a,h
	or	l
	jp	nz,%2
	ld	hl,%3
=
; uchar x != %1 - l_ne returns 1 if not equal
	ld	a,(hl)
	cp	%1
	jp	nz,%2
	ld	hl,%3

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_ne
	ld	a,h
	or	l
	jp	z,%2
	ld	hl,%3
=
; Optimized char x != %1 jp z,%2
	ld	a,(hl)
	cp	%1
	jp	z,%2
	ld	hl,%3

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_eq
	ld	a,h
	or	l
	jp	nz,%2
	ld	hl,%3
=
; char x == %1
	ld	a,(hl)
	cp	%1
	jp	z,%2
	ld	hl,%3

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_eq
	ld	a,h
	or	l
	jp	z,%2
	ld	hl,%3
=
; Optimized char x == %1 jp z,%2
	ld	a,(hl)
	cp	%1
	jp	nz,%2
	ld	hl,%3

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_and
	ld	a,h
	or	l
	jp	nz,%2
	ld	hl,%3
=
; Optimized char & %1 == 0 jp %2
	ld	a,(hl)
	and	%1
	jp	nz,%2
	ld	hl,%3

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_and
	ld	a,h
	or	l
	jp	z,%2
	ld	hl,%3
=
; Optimized char & %1 == 0 jp %2
	ld	a,(hl)
	and	%1
	jp	z,%2
	ld	hl,%3

	push	hl
	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_or
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
; Optimized char x = x | %1
	ld	a,(hl)
	or	%1
	ld	(hl),a
	ld	hl,%2

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_or
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
; Optimized char x = char y | %1
	ld	a,(hl)
	or	%1
	pop	de
	ld	(de),a
	ld	hl,%2

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_and
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
;Optimized char x = char y & %1
	ld	a,(hl)
	and	%1
	pop	de
	ld	(de),a
	ld	hl,%2

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_xor
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
;Optimized char =x char y ^ %1
	ld	a,(hl)
	xor	%1
	pop	de
	ld	(de),a
	ld	hl,%2

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_and
	ld	a,h
	or	l
	jp	z,%2
	ld	hl,%3
=
; Optimized char & %1 in if stmt
	ld	a,(hl)
	and	%1
	jp	z,%2
	ld	hl,%3

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_and
	add	hl,hl
=
; Optimized char & %1 * 2
	ld	a,(hl)
	and	%1
	ld	l,a
	ld	h,0
	add	hl,hl

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_and
	push	hl
	ld	hl,%2
	pop	de
	call	l_ne
	ld	a,h
	or	l
	jp	nz,%3
=
; Optimized char & %1 == %2
	ld	a,(hl)
	and	%1
	cp	%2
	ld	hl,1
	jp	nz,%3
	dec	hl

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_and
	push	hl
	ld	hl,%2
	pop	de
	call	l_ne
	ld	a,h
	or	l
	jp	z,%3
=
; Optimized char & %1 != %2
	ld	a,(hl)
	and	%1
	cp	%2
	ld	hl,0
	jp	z,%3
	inc	hl

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_or
	push	hl
	ld	hl,%2
	pop	de
	call	l_ne
	ld	a,h
	or	l
	jp	z,%3
=
; Optimized char | %1 != %2
	ld	a,(hl)
	or	%1
	cp	%2
	ld	hl,0
	jp	z,%3
	inc	hl

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_xor
	push	hl
	ld	hl,%2
	pop	de
	call	l_ne
	ld	a,h
	or	l
	jp	z,%3
=
; Optimized char ^ %1 != %2
	ld	a,(hl)
	xor	%1
	cp	%2
	ld	hl,0
	jp	z,%3
	inc	hl

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_and
	push	hl
	ld	hl,%2
	pop	de
	call	l_eq
	ld	a,h
	or	l
	jp	z,%3
=
; Optimized char & %1 == %2
	ld	a,(hl)
	and	%1
	cp	%2
	ld	hl,0
	jp	nz,%3
	inc	hl

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_or
	push	hl
	ld	hl,%2
	pop	de
	call	l_eq
	ld	a,h
	or	l
	jp	z,%3
=
; Optimized char | %1 == %2
	ld	a,(hl)
	or	%1
	cp	%2
	ld	hl,0
	jp	nz,%3
	inc	hl

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_xor
	push	hl
	ld	hl,%2
	pop	de
	call	l_eq
	ld	a,h
	or	l
	jp	z,%3
=
; Optimized char ^ %1 != %2
	ld	a,(hl)
	xor	%1
	cp	%2
	ld	hl,1
	jp	nz,%3
	dec	hl

	push	hl
	ld	l,(hl)
	ld	h,0
	inc	hl
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
; Optimized ++char
	inc	(hl)
	ld	hl,%2

	push	hl
	ld	l,(hl)
	ld	h,0
	dec	hl
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
; Optimized --char
	dec	(hl)
	ld	hl,%2

	push	hl
	ld	l,(hl)
	ld	h,0
	inc	hl
	pop	de
	ld	a,l
	ld	(de),a
	dec	hl
	ld	hl,%2
=
; Optimized char++
	inc	(hl)
	ld	hl,%2

	push	hl
	ld	l,(hl)
	ld	h,0
	dec	hl
	pop	de
	ld	a,l
	ld	(de),a
	inc	hl
	ld	hl,%2
=
; Optimized char--
	dec	(hl)
	ld	hl,%2

	ld	hl,1
	add	hl,sp
	push	hl
	ld	hl,2
	add	hl,sp
=
; Optimized close stack operation
	ld	hl,1
	add	hl,sp
	push	hl
	inc	hl

	push	hl
	ld	l,(hl)
	ld	h,0
	inc	hl
	pop	de
	ld	a,l
	ld	(de),a
	dec	hl
	pop	de
	add	hl,de
=
;Optimized char++ of index to char array
	ld	e,(hl)
	inc	(hl)
	ld	d,0
	pop	hl
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	dec	hl
	pop	de
	ld	a,l
	ld	(de),a
	inc	hl
	pop	de
	add	hl,de
=
;Optimized char--  of index to char array
	ld	e,(hl)
	dec	(hl)
	ld	d,0
	pop	hl
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	inc	hl
	pop	de
	ld	a,l
	ld	(de),a
	pop	de
	add	hl,de
=
;Optimized ++char of index to char array
	inc	(hl)
	ld	e,(hl)
	ld	d,0
	pop	hl
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	dec	hl
	pop	de
	ld	a,l
	ld	(de),a
	pop	de
	add	hl,de
=
;Optimized --char  of index to char array
	dec	(hl)
	ld	e,(hl)
	ld	d,0
	pop	hl
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	inc	hl
	pop	de
	ld	a,l
	ld	(de),a
	dec	hl
	add	hl,hl
	pop	de
	add	hl,de
=
;Optimized char++ of index to int array
	ld	e,(hl)
	inc	(hl)
	ld	d,0
	ex	de,hl
	add	hl,hl
	pop	de
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	dec	hl
	pop	de
	ld	a,l
	ld	(de),a
	inc	hl
	add	hl,hl
	pop	de
	add	hl,de
=
;Optimized char--  of index to int array
	ld	e,(hl)
	dec	(hl)
	ld	d,0
	ex	de,hl
	add	hl,hl
	pop	de
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	inc	hl
	pop	de
	ld	a,l
	ld	(de),a
	add	hl,hl
	pop	de
	add	hl,de
=
;Optimized ++char of index to int array
	inc	(hl)
	ld	l,(hl)
	ld	h,0
	add	hl,hl
	pop	de
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	dec	hl
	pop	de
	ld	a,l
	ld	(de),a
	add	hl,hl
	pop	de
	add	hl,de
=
;Optimized --char  of index to int array
	dec	(hl)
	ld	l,(hl)
	ld	h,0
	add	hl,hl
	pop	de
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	inc	hl
	pop	de
	ld	a,l
	ld	(de),a
	dec	hl
	add	hl,hl
	add	hl,hl
	pop	de
	add	hl,de
=
;Optimized char++ of index to long array
	ld	e,(hl)
	inc	(hl)
	ld	d,0
	ex	de,hl
	add	hl,hl
	add	hl,hl
	pop	de
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	dec	hl
	pop	de
	ld	a,l
	ld	(de),a
	inc	hl
	add	hl,hl
	add	hl,hl
	pop	de
	add	hl,de
=
;Optimized char--  of index to long array
	ld	e,(hl)
	dec	(hl)
	ld	d,0
	ex	de,hl
	add	hl,hl
	add	hl,hl
	pop	de
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	inc	hl
	pop	de
	ld	a,l
	ld	(de),a
	add	hl,hl
	add	hl,hl
	pop	de
	add	hl,de
=
;Optimized ++char of index to long array
	inc	(hl)
	ld	l,(hl)
	ld	h,0
	add	hl,hl
	add	hl,hl
	pop	de
	add	hl,de

	push	hl
	ld	l,(hl)
	ld	h,0
	dec	hl
	pop	de
	ld	a,l
	ld	(de),a
	add	hl,hl
	add	hl,hl
	pop	de
	add	hl,de
=
;Optimized --char  of index to long array
	dec	(hl)
	ld	l,(hl)
	ld	h,0
	add	hl,hl
	add	hl,hl
	pop	de
	add	hl,de

	ld	bc,%1
	add	hl,bc
	ld	bc,%2
	add	hl,bc
=
;Optimized repeated ld bc,%1 add hl,bc ld bc,%2 add hl,bc 
	ld	bc,%1+%2
	add	hl,bc

	ld	l,(hl)
	ld	h,0
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%1
=
;Optimized copy of char
	ld	a,(hl)
	pop	de
	ld	(de),a
	ld	hl,%1

	push	hl
	ld	hl,%1
	pop	de
	call	l_pint
	ld	hl,%2
=
; Optimized set int to %1
	ld	(hl),( %1 % 256)
	inc	hl
	ld	(hl),( %1 / 256)
	ld	hl,%2

	ld	hl,2
	add	hl,sp
	call	l_gint
	push	hl
	ld	hl,2
	add	hl,sp
	call	l_gint
	push	hl
=
; Optimized func call param loading (func(2nd,1st) - int posns of stack)
	pop	de
	pop	hl
	push	hl
	push	de
	push	hl
	push	de

	push	hl
	ld	l,(hl)
	ld	h,0
	ld	bc,%1
	add	hl,bc
	pop	de
	ld	a,l
	ld	(de),a
=
; Optimized add %1 to unsigned char
	ld	a,(hl)
	add	a,%1
	ld	(hl),a

	ld	a,(%1
	ld	l,a
	ld	h,0
=
; Optimized pick up static char
	ld	hl,(%1
	ld	h,0

	ld	l,(hl)
	ld	h,0
	ld	a,h
	or	l
	jp	nz,%1
	ld	hl,%2
=
; Optimized if (uchar == 0) {
	ld	a,(hl)
	and	a
	jp	nz,%1
	ld	hl,%2

	ld	l,(hl)
	ld	h,0
	ld	a,h
	or	l
	jp	z,%1
	ld	hl,%2
=
; Optimized if (char) {
	ld	a,(hl)
	and	a
	jp	z,%1
	ld	hl,%2

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_ult
	ld	a,h
	or	l
	jp	z,%2
	ld	hl,%3
=
; Optimized if ( uchar < %1 )  (only if char isn't used) (ugly)
	ld	a,(hl)
	cp	%1
	jp	z,%2
	jp	nc,%2
	ld	hl,%3

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_ule
	ld	a,h
	or	l
	jp	z,%2
	ld	hl,%3
=
; Optimized if (uchar <= %1 ) (only if char isn't used) (l_ule =1 if <=)
	ld	a,(hl)
	cp	%1
	jr	z,ASMPC+5
	jp	nc,%2
	ld	hl,%3

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_ugt
	ld	a,h
	or	l
	jp	z,%2
	ld	hl,%3
=
; optimized if (uchar > %1 )  (only if char isn't used)
	ld	a,(hl)
	cp	%1
	jp	z,%2
	jp	c,%2
	ld	hl,%3

	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1
	pop	de
	call	l_uge
	ld	a,h
	or	l
	jp	z,%2
	ld	hl,%3
=
; optimized ( uchar >= %1 ) (only if char not used)
	ld	a,(hl)
	cp	%1
	jr	z,ASMPC+5
	jp	c,%2
	ld	hl,%3

	ld	(%1),hl
	ld	hl,(%1)
=
; optimized unnecessary pick up of static int
	ld	(%1),hl

	ld	(%1),hl
	ld	(%1+2),de
	ld	hl,(%1)
	ld	de,(%1+2)
=
; optimized uneccessaray pick up static long
	ld	(%1),hl
	ld	(%1+2),de

	ld	hl,%1
	ld	de,%2
	pop	bc
	push	hl
	call	l_int2long_s
=
; removed int2long_s for long a=int b=long const for TOS
	ld	hl,%1
	ld	de,%2
	pop	bc
	push	hl

	ld	hl,%1
	ld	de,%2
	pop	de
	pop	bc
	push	hl
	push	de
	call	l_int2long_s
=
;rearranged long a=int b=long const for 2nd on stack
	ld	hl,%1
	pop	de
	pop	bc
	push	hl
	push	de
	ld	de,%2

	pop	de
	pop	bc
	push	hl
	push	de
	ld	hl,2
	add	hl,sp
	call	l_gint
	pop	bc
	pop	bc
	ret
=
; Optimized return(2nd int on stack) after setting it to a value
	pop	bc
	pop	bc
	ret

	call	l_gint
	ld	hl,0
=
	ld	hl,0

	call	l_glong
	ld	hl,0
	ld	de,0
=
	ld	hl,0
	ld	d,h
	ld	e,l

	and	1
	jp	z,%1
=
	rrca
	jp	nc,%1

	and	1
	jp	nz,%1
=
	rrca
	jp	c,%1

	and	128
	jp	z,%1
=
	rlca
	jp	nc,%1

	and	128
	jp	nz,%1
=
	rlca
	jp	c,%1

	and	%1
	cp	%1
=
	and	%1
