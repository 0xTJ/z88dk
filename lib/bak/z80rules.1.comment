	ld	a,0
=
	xor	a

	ld	hl,%0
	ld	a,l
	ld	(%1),a
=
;	%1 = char %0
	ld	a,%0
	ld	(%1),a

	jp	%0
.%0
=
; jp %0 \n .%0 cancelled
.%0

	ld	de,8
	ex	de,hl
	call	l_asr_u
=
; Shift right unsigned by 8 optimized
	ld	l,h
	ld	h,0

	ld	de,8
	ex	de,hl
	call	l_asr
=
;Shift right by 8 optimized
	ld	a,h
	call	l_sxt

	ld	de,0
	ex	de,hl
	call	l_asr
=
;Shift right by 0 opted (nothing required)

	ld	de,8
	ex	de,hl
	call	l_asl
=
;Shift left by 8
	ld	h,l
	ld	l,0

	ld	de,0
	ex	de,hl
	call	l_asl
=
;Shift left by 0 (unneeded)

	ld	hl,0
	add	hl,sp
	push	hl
	call	l_gint
	inc	hl
	pop	de
	call	l_pint
=
;Increment int at top of stack optimised (from ++)
	pop	hl
	inc	hl
	push	hl

	ld	hl,0
	add	hl,sp
	call	l_gint
	inc	hl
	pop	bc
	push	hl
=
;Increment int at top of stack optimized (from j=j+1)
	pop	hl
	inc	hl
	push	hl

	ld	hl,0
	add	hl,sp
	call	l_gint
	ld	de,%1
	add	hl,de
	pop	bc
	push	hl
=
;Add %1 to top int on stack (also for sub)
	pop	hl
	ld	de,%1
	add	hl,de
	push	hl

	ld	hl,0
	add	hl,sp
	call	l_gint
	dec	hl
	pop	bc
	push	hl
=
;Decrement int at top of stack optimised (j=j-1)
	pop	hl
	dec	hl
	push	hl

	ld	hl,0
	add	hl,sp
	push	hl
	call	l_gint
	dec	hl
	pop	de
	call	l_pint
=
;Decrement int at top of stack (from j--)
	pop	hl
	dec	hl
	push	hl

	ld	hl,2
	add	hl,sp
	push	hl
	call	l_gint
	inc	hl
	pop	de
	call	l_pint
=
;Increment 2nd int at top of stack optimised (from ++)
	pop	de
	pop	hl
	inc	hl
	push	hl
	push	de

	ld	hl,2
	add	hl,sp
	call	l_gint
	inc	hl
	pop	de
	pop	bc
	push	hl
	push	de
=
;Increment 2nd int at top of stack optimized (from j=j+1)
	pop	de
	pop	hl
	inc	hl
	push	hl
	pop	de

	ld	hl,0
	add	hl,sp
	call	l_gint
	ld	de,%1
	add	hl,de
	pop	de
	pop	bc
	push	hl
	push	de
=
;Add %1 to 2nd top int on stack (also for sub)
	pop	de
	pop	hl
	ld	bc,%1
	add	hl,bc
	push	hl
	push	de

	ld	hl,2
	add	hl,sp
	call	l_gint
	dec	hl
	pop	de
	pop	bc
	push	hl
	push	de
=
;Decrement int at top of stack optimised (j=j-1)
	pop	de
	pop	hl
	dec	hl
	push	hl
	push	de

	ld	hl,0
	add	hl,sp
	push	hl
	call	l_gint
	dec	hl
	pop	de
	call	l_pint
=
;Decrement int at top of stack (from j--)
	pop	de
	pop	hl
	dec	hl
	push	hl
	push	de

	ld	hl,0
	add	hl,sp
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
=
;Inlined int of top off stack optimized
	pop	hl
	push	hl

	ld	hl,2
	add	hl,sp
	call	l_gint
=
;Fetch second into off stack optimized
	pop	bc
	pop	hl
	push	hl
	push	bc

	ld	hl,2
	add	hl,sp
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
=
;Inline second int off stack optimized
	pop	bc
	pop	hl
	push	hl
	push	bc

	call	dload
	call	dpush
=
; call dload, dpush -> dldpsh
	call	dldpsh

	jp	nz,%1
	jp	z,%2
.%1
=
; Jump over jp z,%2
	jp	z,%2
.%1

	jp	z,%1
	jp	nz,%2
.%1
=
;Jump over jp nz,%2
	jp	nz,%2
.%1

	jp	z,%1
	call	%2
.%1
=
;jp z,%1 around call %2
	call	nz,%2
.%1

	jp	nz,%1
	call	%2
.%1
=
;jp nz,%1 around call %2
	call	z,%2
.%1

	call	%1
	ret
=
;Removing ret following call %1
	jp	%1

	ld	hl,%1
	ex	de,hl
	ld	hl,%2
=
;ld hl,ex,ld hl
	ld	de,%1
	ld	hl,%2

	ld	(%1),%2
	ld	%2,(%1)
=
;ld (%1),%2;ld %2,(%1)
	ld	(%1),%2

	jp	z,%1
	ret
.%1
=
;Jp z, over non conditional return
	ret	nz
.%1

	jp	nz,%1
	ret
.%1
=
;jp nz over non conditonal ret
	ret	z
.%1

	push	hl
	ld	hl,%1
	pop	de
=
;push hl, ld hl,%1 pop de optimized
	ld	de,%1
	ex	de,hl

	ld	hl,0
	add	hl,sp
	call	l_gint
=
;Get top int off stack optimized
	pop	hl
	push	hl

	ld	hl,%1
	add	hl,sp
	ld	de,%2
	add	hl,de
=
;Optimized offset into stack 
	ld	hl,%1+%2
	add	hl,sp

	ld	hl,%1
	add	hl,sp
	inc	hl
=
;Optimized add hl,sp inc hl
	ld	hl,%1+1
	add	hl,sp

	ld	de,0
	ex	de,hl
	call	l_eq
	ld	a,h
	or	l
	jp	nz,%1
=
;Optimized check for 0 -> l_eq
	ld	a,h
	or	l
	jp	z,%1

	ld	de,%1
	ex	de,hl
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
;Set char to number, but not when result is used
	ld	(hl),(%1 % 256)
	ld	hl,%2

	push	de
	push	hl
	ld	hl,1
	ld	de,0
	call	l_long_add
=
; Add one to long optimized 
	call	l_inclong

	push	de
	push	hl
	ld	hl,2
	ld	de,0
	call	l_long_add
=
; Add two to long optimized
	call	l_inclong
	call	l_inclong

	push	de
	push	hl
	ld	hl,-1
	ld	de,65535
	call	l_long_add
=
; Sub one from long optimized
	call	l_declong

	dec	hl
	ld	hl,%1
=
; Removed redundant dec hl instruction
	ld	hl,%1

	inc	hl
	ld	hl,%1
=
; Removed redundant inc hl insruction
	ld	hl,%1

	add	hl,%1
	ld	hl,%2
; Removed redundant add hl,%1 instruction
	ld	hl,%2

	push	bc
	pop	bc
	push	hl
=
; Optimized push bc, pop bc, push hl -> push hl
	push	hl

	push	bc
	ld	hl,%1
	pop	bc
	push	hl
=
; Optimized push bc, ld hl,%1 pop bc push hl -> ld hl,%1 push hl
	ld	hl,%1
	push	hl

	pop	hl
	push	hl
	pop	bc
	ret
=
; Optimized pop hl, push hl, pop bc, ret usu from return(n) if n is top 
	pop	hl
	ret

	ld	a,h
	or	l
	jp	nz,%1
	ld	hl,0
	pop	bc
	ret
=
; Optimized return(0) after failed test for != 0 (one on stack)
	ld	a,h
	or	l
	jp	nz,%1
	pop	bc
	ret

	ld	hl,smc_%1
	ld	bc,%2
	add	hl,bc
=
; optimized ld hl,smc_%1 ld bc,%2 add hl,bc (usu from array access)
	ld	hl,smc_%1+%2

	ld	hl,smc_%1
	inc	hl
=
; optimized ld hl,smc_%1 inc hl (usu from array access)
	ld	hl,smc_%1+1

	ld	hl,smc_%1
	call	l_gint
=
; optimized ld hl,smc_%1 call l_gint
	ld	hl,(smc_%1)

	ld	hl,smc_%1
	call	l_glong
=
; optimized (speed) pick up long from hl
	ld	hl,(smc_%1)
	ld	de,(smc_%1+2)

	ld	hl,smc_%1
	ld	l,(hl)
	ld	h,0
=
; optimized get unsigned char from hl (usu array)
	ld	hl,(smc_%1)
	ld	h,0

	ld	hl,%1
	jp	%2
	ld	hl,%1
=
; Optimized unnecessry repeated load of hl around jp
	ld	hl,%1
	jp	%2

	pop	bc
	pop	hl
	push	hl
	push	bc
	pop	bc
	pop	bc
	ret
=
; Optimized return(n) where n is second arg on stack
	pop	bc
	pop	hl
	ret

	pop	bc
	push	hl
;%1
	pop	hl
	push	hl
=
; Optimized pointless reloading of top integer on stack (After storage)
	pop	bc
	push	hl

	pop	hl
	push	hl
	ld	bc,%1
	add	hl,bc
	pop	bc
	push	hl
=
; Optimized add %1 to top int on stack
	pop	hl
	ld	bc,%1
	add	hl,bc
	push	hl

	push	bc
	push	bc
	ld	hl,%1
	pop	de
	pop	bc
	push	hl
	push	de
=
; Optimized set 2nd int on stack
	ld	hl,%1
	push	hl
	push	bc

	ld	hl,smc_%1
;%2
	ld	a,(hl)
	cp	%3
=
; Optimized pick up uchar (for compare)
;%2
	ld	a,(smc_%1)
	cp	%3

	ld	hl,smc_%1
;%2
	ld	a,(hl)
	and	a
=
; optimized pick up uchar (for compare == 0 )
	ld	a,(smc_%1)
	and	a

	ld	de,%1
	pop	de
=
; optimized long const -> int (discard ld de,%1)
	pop	de

	pop	bc
	ld	hl,%1
	add	hl,sp
	ld	sp,hl
=
	ld	hl,%1+2
	add	hl,sp
	ld	sp,hl

	exx
	ld	hl,%1
	add	hl,sp
	ld	sp,hl
	exx
	ld	hl,%2
	add	hl,sp
	ld	sp,hl
=
; Optimized restore of stack after functions with > 6 bytes on stack
	exx
	ld	hl,%1+%2
	add	hl,sp
	ld	sp,hl
	exx

	ld	de,%1
	pop	de
=
; Removed pointless ld de,%1 before pop de  (usu from cast)
	pop	de

	call	l_int2long_s
	pop	de
=
; Removed pointless call l_int2long_s before pop de (from cast)
	pop	de

	jp	i_%1
	jp	i_%2
=
; Removed pointless jp i_%2 after jp i_%1
	jp	i_%1

	ld	hl,%1
	add	hl,sp
	ld	bc,%2
	add	hl,bc
=
; Optimized get offset into stack (usu array/struct access)
	ld	hl,%1+%2
	add	hl,sp

	call	l_inclong
	ld	hl,%1
=
; Removed unnecessary call l_inclong
	ld	hl,%1

	call	l_declong
	ld	hl,%1
=
; Removed unnecessary call l_declong
	ld	hl,%1

	call	exit
	pop	%1
=
; Removed unecessary pop %1 after call exit
	call	exit

	call	exit
	ld	hl,%1
	add	hl,sp
	ld	sp,hl
=
; Removed unnecessary equalise stack after call exit
	call	exit

	push	hl
	pop	bc
	ret
=
; Removed mc lib func __FASTCALL__ push hl, pop bc ret combo
	ret

	cp	0
=
	and	a
