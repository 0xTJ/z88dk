;       CRT0 for the ZX81 - HIGH RESOLUTION MODE (arx816 trick by Andy Rea)
;       Display handler modifications (to preserve IY) by Stefano Bodrato
;
;
; - - - - - - -
;
;       $Id: zx81_hrg_arx.def,v 1.1 2011-10-22 08:37:36 stefano Exp $
;
; - - - - - - -

XDEF	hrg_on
XDEF	hrg_off
XDEF	HRG_LineStart
XDEF	HRG_Handler


IF ((startup=13)|(startup=15))
hrgbrkflag:
        defb    0
ENDIF

;--------------------------------------------------------------
;--------------------------------------------------------------

;------------------------------------------
;
;   ZX81 system variables
;
;------------------------------------------
;DEFC   ERR_NR  = 16384 ;byte   one less than the report code
;DEFC   FLAGS   = 16385 ;byte   flags to control the BASIC system.
;DEFC   MODE    = 16390 ;byte   Specified K, L, F or G cursor.
;DEFC   PPC     = 16391 ;word   Line number of statement currently being executed

DEFC    ERR_SP  = 16386 ;word   Address of first item on machine stack (after GOSUB returns).
DEFC    RAMTOP  = 16388 ;word   Address of first byte above BASIC system area. 


;----------------------------------------------------------------
;
; Switch to HRG mode 
; "base_graphics" has to point to a reasonable adress
;
;----------------------------------------------------------------
hrg_on:
	call   $F2B	; SLOW
IF !DEFINED_hrgpage
        ld      hl,(base_graphics)
        ld      a,h
        or      l
        jr      nz,no_default_base
        ld      hl,$2000      ; set base_graphics
        ld      (base_graphics),hl
.no_default_base
ENDIF
IF (startup=17)
        ld  hl,(base_graphics)
        ld	(graybit1),hl
        ld	de,$2000
        add	hl,de
        ld	(graybit2),hl
        ld	(current_graphics),hl
ENDIF
	call	HRG_Sync
        ld      iy,HRG_handler  ; starts the hires mode when JP (IX) is made
        ret

;----------------------------------------------------------------
;
; Switch to TXT mode
;
;----------------------------------------------------------------
hrg_off:
	call	HRG_Sync
        ld      iy,$281    ; switch back to text (original video routine)
        ld      a,$1e
        ld      i,a
        ret

;----------------------------------------------------------------
;
; Sync display before mode switching
;
;----------------------------------------------------------------
HRG_Sync:
        ld      hl,$4034        ; FRAMES counter
        ld      a,(hl)          ; get old FRAMES
HRG_Sync1:
        cp      (hl)            ; compare to new FRAMES
        jr      z,HRG_Sync1     ; exit after a change is detected
        ret

;----------------------------------------------------------------
;
; This is the HRG handler
;
; I need to sync my lines with the ULA row counter the effect
; is to slow down basic execution a bit, not sure how much but
; it's effectively 8 scanlline
;
;----------------------------------------------------------------

HRG_handler:
        ld      b,120           ; delay sets the left edge of the screen (was 6 on WRX)
								; Between here and the first execution of the
                                ; LineStart bytes, total delay is equal to 8 scanlines.
HRG_wait_left:
        djnz    HRG_wait_left 
        inc     bc              ;
        nop                     ; 4 T delay fine tuning here!
								; (is it really needed ?)

        ld      d,8
IF (startup>=15)
        ld      b,4             ; 64 /8 scanlines /2 buffers ?
ELSE
        ld      b,12            ; 192 /8 scanlines /2 buffers ?
ENDIF
        ld      c,d

IF (startup=17)                 ; 
        ld      a,(current_graphics+1)   ; 13 T We will get the MSB, $20 or $40
ELSE
        ld      a,$20                    ; 7 T
ENDIF
        ld      i,a             ; load MSB into I register which is RFSH address MSB


HRG_outloop1:
        call    (HRG_LineStart + $8000)
        nop                     ; 159 t states so far (138 from 1st buffer) timing
        dec     c               ;
        jp      z,HRG_outloop2
        ld      a,i             ; this way if not 8 scanlines
        ld      a,i
        nop
        jr      HRG_outloop1

HRG_outloop2:                   ; this route is taken if 8 scanlines have been completed.
        ld      a,i             ; just timing stuff
        inc     bc
        inc     bc
        ld      c,d
        ld      a,i
        
HRG_outloop3:                             ; start of the second inner loop
        call    (HRG_LineStart2 + $8000)  ; fire the second "character row"
        dec     c                         ; 159 t states (138 from 2nd buffer)
        jp      z,HRG_outloop4
        ld      a,i             ; this way if not 8 scanlines
        ld      a,i
        inc     a               ; increment A by two,
        inc     a               ; ready for the other branch
        jr      HRG_outloop3
        
HRG_outloop4:
        ld      c,d             ; reset scan line counter
        ld      i,a             ; set i to next 512 byte block#
        ld      a,(hl)
        nop
        dec     b
        jp      nz,HRG_outloop1

; -------------------------------------------------------
; 

        ld	hl,(frames)	; clock handler
        inc	hl
        ld	(frames),hl
        ld	a,h
        or	l
        jp	nz,nofr1
        ld	hl,frames+1
        inc	(hl)
nofr1:

        ;call   $0292          ; return to application program

; Different from original call to keep IY unchanged
; and to eventually add blank lines

        ld      iy,pointedbyix ; in ROM we'd have had a POP IX and JP IX as a 'return'
        ld      a,(16424)      ; 33 or 19 blank lines in bottom MARGIN

; this idea comes from the Wilf Rigter's WRX1K hi-resolution implementation
; if we run in 64 lines mode we need to increase the number of border's lines

IF (startup>=15)
        add     140-8    ; more blank lines for fast application code and correct sync
        			; For the WRX version Siegfried Engel reports that values between 
        			; 80 and 159 worked fine on both a normal TV and an LCD one
ELSE
        sub     8              ; reduce by 8 scan lines
ENDIF

        ld      c,a            ; load C with MARGIN
        ld      a,(16443)      ; test CDFLAG
        bit     7,a

        jp      $29b           ; save blank lines, start NMI, POP registers and RETURN

pointedbyix:
        push    ix
        ld      ix,16384

        call    $0220          ; first PUSH register, then do VSYNC and get KEYBD

IF ((startup=13)|(startup=15))
        call    $0F46          ; check break (space) key
        jp      c,nobrkk
        ld      a,(hrgbrkflag)     ; set to '0' if program isn't running
        and	a
        jr	z,nobrkk
        SCF
nobrkk:
ENDIF
ELSE
        nop
ENDIF

        pop     ix

IF ((startup=13)|(startup=15))
		jp		c,nobrkk2
        ld      a,$1e           ; the I register is restored with the MSB address
        ld      i,a             ; of the ROM pattern table in case of BREAK key down
        jp      $02A4
nobrkk2:
ENDIF

IF (startup=17)
	ld	hl,gcount
	;res	7,(hl)
	inc	(hl)
	ld	a,(hl)
	dec	a
	jp	z,Display_pic1
	dec	a
	jp	z,Display_pic2
	ld	(hl),0
Display_pic1:
	ld	hl,(graybit1)
	jp	setpage
Display_pic2:
	ld	hl,(graybit2)
setpage:
	ld	(current_graphics),hl
ENDIF

        ld      iy,HRG_handler  ; reload vector if no BREAK or else SINCLAIR video
        ld      a,(16424)      ; 33 or 19 blank lines in bottom MARGIN
        sub     8              ; reduce by 8 scan lines

        jp      $029e           ; now update A', start NMI, POP registers and return to BASIC/programs

;----------------------------------------------------------------
;  Variables for grayscale graphics
;----------------------------------------------------------------

IF (startup=17)
		XDEF	graybit1
		XDEF	graybit2
gcount:
		defb	0
current_graphics:
		defw	0
graybit1:
		defw	0
graybit2:
		defw	0
ENDIF

;----------------------------------------------------------------
;
;	because of the way this ram is addressed during refresh
;	we need 2 dummy d-file lines, the first to do even character
;	rows, the second to do odd character rows. So basically the
;	h-file is laid out like 12 consecutive character maps.
;
;	each buffer is called 8 times as video bytes
;	both repeated 12 times in total,
;	(8+8)*12=192 scanlines.
;
;----------------------------------------------------------------

HRG_LineStart:
;	defb 128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143
;	defb 144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159
	defb 00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15
	defb 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
	ret

HRG_LineStart2:
	defb 32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47
	defb 48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63
	ret


;----------------------------------------------------------------
;
; End of HRG handler
;
;----------------------------------------------------------------

